Original request / feature

- Verify orb reacts to live microphone sound rather than random movement.

Challenges

- Web Audio constructor typing (`webkitAudioContext`) triggered lint/TS complaints.
- Avoiding unused/react-hook lint warnings without refactoring broader state usage.

Successes

- Orb now receives live mic RMS amplitude and animates to sound.
- Added robust audio teardown: tracks, raf, and AudioContext closed on stop.
- Kept fallback random pulsing when no volume prop is provided.

Methods that did/didn’t work

- Did: Web Audio analyser with time-domain RMS via `requestAnimationFrame`.
- Did: Type-safe `AudioContext` constructor fallback for Safari.
- Didn’t pursue: Deepgram-side energy as driver (higher latency, less responsive).

Changes made to the codebase (≤50 lines shown)

```app/page.tsx
const [micVolume, setMicVolume] = useState(0);
const audioContextRef = useRef<AudioContext | null>(null);
const analyserRef = useRef<AnalyserNode | null>(null);
const dataArrayRef = useRef<Uint8Array<ArrayBuffer> | null>(null);
...
const startAudioAnalysis = useCallback((stream: MediaStream) => {
  stopAudioAnalysis();
  const audioCtxConstructor =
    window.AudioContext ||
    (window as typeof window & { webkitAudioContext?: typeof AudioContext })
      .webkitAudioContext;
  if (!audioCtxConstructor) return;
  const audioCtx = new audioCtxConstructor();
  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 512;
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(new ArrayBuffer(bufferLength)) as Uint8Array<ArrayBuffer>;
  const source = audioCtx.createMediaStreamSource(stream);
  source.connect(analyser);
  audioContextRef.current = audioCtx;
  analyserRef.current = analyser;
  dataArrayRef.current = dataArray;
  const updateVolume = () => {
    analyserRef.current?.getByteTimeDomainData(dataArrayRef.current!);
    let sumSquares = 0;
    for (let i = 0; i < dataArrayRef.current!.length; i++) {
      const v = (dataArrayRef.current![i] - 128) / 128;
      sumSquares += v * v;
    }
    const rms = Math.sqrt(sumSquares / dataArrayRef.current!.length);
    setMicVolume(Math.min(1, rms * 2));
    rafRef.current = requestAnimationFrame(updateVolume);
  };
  rafRef.current = requestAnimationFrame(updateVolume);
}, []);
```

```components/orb.tsx
interface OrbProps { active: boolean; volume?: number; }
export function Orb({ active, volume: volumeProp }: OrbProps) {
  const [volume, setVolume] = useState(0);
  useEffect(() => {
    if (!active) { setVolume(0); return; }
    if (typeof volumeProp === "number") { setVolume(volumeProp); return; }
    const interval = setInterval(() => setVolume(0.2 + Math.random() * 0.8), 100);
    return () => clearInterval(interval);
  }, [active, volumeProp]);
```
